/*
 *        JacORB - a free Java ORB
 *
 *   Copyright (C) 1997-2014 Gerald Brose / The JacORB Team.
 *
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Library General Public
 *   License as published by the Free Software Foundation; either
 *   version 2 of the License, or (at your option) any later version.
 *
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   Library General Public License for more details.
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this library; if not, write to the Free
 *   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

package org.jacorb.idl;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.Level;

/**
 * @author Gerald Brose
 */

public class AttrDecl
    extends Declaration
{
    public boolean readOnly;
    public TypeSpec param_type_spec;
    public SymbolList declarators;
    
    public RaisesExpr getRaisesExpr;
    public RaisesExpr setRaisesExpr;

    @SuppressWarnings("rawtypes")
	private Vector operations = new Vector();

    public AttrDecl( int num )
    {
        super( num );
    }

    public void setPackage( String s )
    {
        s = parser.pack_replace( s );
        if( pack_name.length() > 0 )
            pack_name = s + "." + pack_name;
        else
            pack_name = s;
        declarators.setPackage( s );
        param_type_spec.setPackage( s );
        getRaisesExpr.setPackage( s );
        setRaisesExpr.setPackage( s );
    }
    
    public void setEnclosingSymbol( IdlSymbol s )
    {
        if( parser.logger.isLoggable(Level.ALL) )
            parser.logger.log(Level.ALL, "opDecl.setEnclosingSymbol " + s);

        if( enclosing_symbol != null && enclosing_symbol != s )
            throw new RuntimeException( "Compiler Error: trying to reassign container for "
                                        + name );
        if( s == null )
            throw new RuntimeException( "Compiler Error: enclosing symbol is null!");

        enclosing_symbol = s;
        getRaisesExpr.setEnclosingSymbol( s );
        setRaisesExpr.setEnclosingSymbol( s );
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
	public void parse()
    {
        IdlSymbol myInterface = enclosing_symbol;

        if( param_type_spec.typeSpec() instanceof ScopedName )
        {
            TypeSpec ts =
                    ( (ScopedName)param_type_spec.typeSpec() ).resolvedTypeSpec();
            if( ts != null )
                param_type_spec = ts;

            myInterface.addImportedName( ts.typeName() );
        }

        // declarator names can be left unparsed to tolerate buggy
        // IDL generated by rmic
        if (parser.strict_attributes)
        {
            declarators.parse();
        }
        
        getRaisesExpr.parse();
        setRaisesExpr.parse();

        for (Enumeration e = declarators.v.elements(); e.hasMoreElements();)
        {
            operations.addElement(
                    new Method( param_type_spec,
                            null,
                            ( (SimpleDeclarator)e.nextElement() ).name(),
                            getRaisesExpr,
                            is_pseudo)
            );
        }

        if (!readOnly)
        {
            for( Enumeration e = declarators.v.elements(); e.hasMoreElements(); )
            {
                SimpleDeclarator d =
                        (SimpleDeclarator)e.nextElement();
                operations.addElement(
                        new Method( null,
                                param_type_spec,
                                d.name(),
                                setRaisesExpr,
                                is_pseudo )
                );
            }
        }
    }

    @SuppressWarnings("rawtypes")
	public void print( PrintWriter ps , Vector<String> template )
    {
    	//FIXME
    	boolean judge = false;
    	if(template.get(0).contains(":readonly") && !readOnly)
    		return;
    	else if(template.get(0).contains(":normal") && readOnly)
    		return;
    	
    	for( Enumeration e = declarators.elements(); e.hasMoreElements(); )
    	{
    		Declarator d = (Declarator) e.nextElement();
    		int i = 1 ;
    		while(i < template.size())
        	{
    			if(template.get(i).startsWith("%newfile"))
            	{
            		judge = true;
            		String tmp = template.get(i).replaceAll("<attributeName>", name);
            		PrintWriter _ps;
            		
            		try{
    					_ps = openOutput(tmp.substring(9));
    					if(_ps == null)
    						throw new Exception();
    				}catch(Exception e1){
    					throw new RuntimeException ("文件"+tmp+"已存在,代码生成失败");
    				}
            		
            		if(ps != null)
            		{
            			ps.close();
            			ps = _ps;
            		}
            		else
            			ps = _ps;
            		
            		i = i+1;
            	}
    			if(ps == null)
    				throw new RuntimeException ("模板代码有误,文件已被关闭");
        		if(template.get(i).startsWith("%getraises"))
        		{
        			Vector<String> _template = new Vector<String>();
        			i = i+1;
        			while(!template.get(i).equals("%%"))
        			{
        				String tmp = template.get(i).replaceAll("<attributeType>", param_type_spec.typeName());
            			tmp = tmp.replaceAll("<attributeName>", d.toString());
            			_template.add(tmp);
            			i = i+1;
        			}
        			getRaisesExpr.print(ps, _template);
        			i = i+1;
        		}
        		else if(template.get(i).startsWith("%setraises"))
        		{
        			Vector<String> _template = new Vector<String>();
        			i = i+1;
        			while(!template.get(i).equals("%%"))
        			{
        				String tmp = template.get(i).replaceAll("<attributeType>", param_type_spec.typeName());
            			tmp = tmp.replaceAll("<attributeName>", d.toString());
            			_template.add(tmp);
            			i = i+1;
        			}
        			setRaisesExpr.print(ps, _template);
        			i = i+1;
        		}
        		else
        		{
        			String tmp = template.get(i).replaceAll("<attributeType>", param_type_spec.typeName());
        			tmp = tmp.replaceAll("<attributeName>", d.toString());
        			ps.println(tmp);
        			i = i+1;
        		}
        	}
    		if(ps != null && judge)
            	ps.close();
    	}
    }

    @SuppressWarnings("rawtypes")
	public Enumeration getOperations()
    {
        return operations.elements();
    }

    /**
     * collect Interface Repository information in the argument hashtable
     */

    @SuppressWarnings({ "rawtypes", "unchecked" })
	public void getIRInfo( Hashtable irInfoTable )
    {
        for( Enumeration e = declarators.v.elements(); e.hasMoreElements(); )
        {
            String fullName = param_type_spec.full_name();
            irInfoTable.put( ( (SimpleDeclarator)e.nextElement() ).name(),
                    "attribute" + ( readOnly?"":"-w" ) + ";" +
                    ( fullName != null ? fullName :  param_type_spec.typeName() ) );
        }
    }
    
    protected PrintWriter openOutput(String typeName)
    {
        try
        {
            final File f = new File(parser.out_dir+"\\"+typeName);
            if (GlobalInputStream.isMoreRecentThan(f))
            {
                PrintWriter ps = new PrintWriter(new java.io.FileWriter(f));
                return ps;
            }

            // no need to open file for printing, existing file is more
            // recent than IDL file.

            return null;
        }
        catch (IOException e)
        {
            throw new RuntimeException ("Could not open output file for "
                                        + typeName + " (" + e + ")");
        }
    }
}







